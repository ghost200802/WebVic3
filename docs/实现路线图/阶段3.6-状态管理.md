# 阶段3.6：状态管理

## 目标

实现框架无关的游戏状态管理系统，支持跨平台使用。

**重要提示：**
- 本文档只包含接口定义和功能要求，不包含详细代码实现
- 核心状态管理必须框架无关，不依赖Vue/React/Cocos
- 完成后必须进行单元测试
- 测试覆盖率 > 80% 才能进入下一阶段

---

## 任务清单

- [ ] 实现游戏状态接口
- [ ] 实现状态提供者
- [ ] 实现状态订阅机制
- [ ] 实现状态持久化
- [ ] 实现状态派生计算
- [ ] 编写单元测试

---

## 架构设计说明

### 核心原则

**框架无关设计：**
- 状态管理不依赖任何UI框架
- 使用观察者模式实现订阅机制
- 纯函数实现状态更新
- 支持在Vue、React、Cocos Creator中复用

### 状态分层

```
GameState (核心状态)
  ├── TimeState (时间状态)
  ├── EraState (时代状态)
  ├── PopulationState (人口状态)
  ├── BuildingState (建筑状态)
  ├── MarketState (市场状态)
  ├── TechnologyState (科技状态)
  └── SettingsState (设置状态)
```

### 更新机制

**单向数据流：**
```
Action → Reducer → NewState → Notify Subscribers
```

---

## 接口定义要求

### IGameStateProvider接口

```
interface IGameStateProvider {
  getState(): GameState
  dispatch(action: GameAction): void
  subscribe(listener: StateListener): () => void
  unsubscribe(listener: StateListener): void
  getPersistedState(): PersistedState
  restorePersistedState(data: PersistedState): void
}
```

### GameState接口

```
interface GameState {
  date: GameDate
  era: Era
  isPaused: boolean
  timeMultiplier: number
  population: Map<string, Population>
  buildings: Map<string, Building>
  market: Market
  technologies: {
    researched: Set<string>
    queue: ResearchQueue
  }
  settings: GameSettings
  notifications: Notification[]
}
```

### GameAction接口

```
interface GameAction {
  type: string
  payload?: any
  timestamp: number
}
```

### StateListener接口

```
type StateListener = (state: GameState, previousState: GameState) => void
```

### PersistedState接口

```
interface PersistedState {
  date: GameDate
  era: Era
  population: Map<string, Population>
  buildings: Map<string, Building>
  market: Market
  technologies: {
    researched: Set<string>
  }
  settings: GameSettings
}
```

### IStateSelector接口

```
interface IStateSelector<T> {
  select(state: GameState): T
  subscribe(listener: (value: T) => void): () => void
}
```

---

## 功能要求

### 状态获取功能

- 获取完整游戏状态
- 获取状态快照（不可变副本）
- 支持选择性获取子状态

### 状态更新功能

- 通过Action更新状态
- 纯函数Reducer实现状态转换
- 支持批量Action执行
- 支持Action队列
- 记录状态变更历史（可选）

### 订阅机制

- 订阅状态变化
- 订阅特定子状态
- 取消订阅
- 通知所有订阅者
- 提供新旧状态对比

### 状态派生计算

- 计算派生状态（如总人口、总收入等）
- 缓存计算结果
- 依赖状态自动更新
- 支持链式派生

### 状态持久化

- 获取需要持久化的状态
- 恢复持久化的状态
- 过滤不需要持久化的字段（如isPaused、notifications）
- 版本兼容性检查

### Action类型定义

**时间相关Action：**
- TICK_TIME - 推进时间
- SET_PAUSE - 暂停游戏
- SET_RESUME - 继续游戏
- SET_TIME_MULTIPLIER - 设置时间倍速

**建筑相关Action：**
- CREATE_BUILDING - 创建建筑
- UPGRADE_BUILDING - 升级建筑
- REMOVE_BUILDING - 删除建筑
- SET_PRODUCTION_METHOD - 设置生产方式

**人口相关Action：**
- ASSIGN_WORKER - 分配工人
- REMOVE_WORKER - 解雇工人
- UPDATE_POPULATION - 更新人口

**市场相关Action：**
- ADD_SUPPLY - 添加供给
- ADD_DEMAND - 添加需求
- EXECUTE_TRANSACTION - 执行交易

**科技相关Action：**
- ADD_TECH_TO_QUEUE - 添加科技到队列
- REMOVE_TECH_FROM_QUEUE - 从队列移除科技
- UNLOCK_TECH - 解锁科技

**通知相关Action：**
- ADD_NOTIFICATION - 添加通知
- REMOVE_NOTIFICATION - 移除通知

---

## 测试要求

### 状态管理测试

- [ ] 测试状态获取
- [ ] 测试Action派发
- [ ] 测试Reducer状态转换
- [ ] 测试订阅和取消订阅
- [ ] 测试多订阅者通知
- [ ] 测试状态快照不可变性
- [ ] 测试状态派生计算
- [ ] 测试持久化功能
- [ ] 测试批量Action执行
- [ ] 测试Action队列
- [ ] 测试状态历史记录（如果实现）

### 测试覆盖率要求

- 代码覆盖率 > 80%
- 所有公共方法必须有测试

---

## 实现文件

在 packages/core/src/state/ 目录下创建以下文件：
- gameState.ts - 游戏状态定义
- gameStateProvider.ts - 状态提供者
- actions.ts - Action类型定义
- reducers.ts - 状态Reducer
- selectors.ts - 状态派生计算器
- index.ts - 导出文件

---

## 测试文件

创建以下测试文件：
- packages/core/src/state/__tests__/gameState.test.ts
- packages/core/src/state/__tests__/gameStateProvider.test.ts
- packages/core/src/state/__tests__/reducers.test.ts
- packages/core/src/state/__tests__/selectors.test.ts

---

## 测试运行

运行单元测试命令：cd packages/core && pnpm test

运行覆盖率测试：cd packages/core && pnpm test:coverage

---

## 完成标准

### 功能实现完成

- [ ] 游戏状态定义完成
- [ ] 状态提供者实现完整
- [ ] 订阅机制实现完整
- [ ] 状态持久化实现完整
- [ ] 状态派生计算实现完整

### 文件创建完成

- [ ] gameState.ts 创建完成
- [ ] gameStateProvider.ts 创建完成
- [ ] actions.ts 创建完成
- [ ] reducers.ts 创建完成
- [ ] selectors.ts 创建完成
- [ ] index.ts 创建完成

### 测试完成

- [ ] 所有单元测试通过
- [ ] 测试覆盖率 > 80%
- [ ] 所有公共函数/方法有测试

### 代码检查完成

- [ ] pnpm typecheck 通过
- [ ] pnpm lint 通过
- [ ] 无TypeScript错误
- [ ] 无ESLint错误

---

## 跨平台使用说明

### Vue3端使用

创建Vue适配器层：

```
// apps/web/src/adapters/coreAdapter.ts
export function createVueAdapter(stateProvider: IGameStateProvider) {
  const store = reactive({
    state: stateProvider.getState(),
  })

  stateProvider.subscribe((newState) => {
    store.state = newState
  })

  return store
}
```

### Cocos Creator端使用

创建Cocos适配器层：

```
// packages/cocos/adapters/coreAdapter.ts
export function createCocosAdapter(stateProvider: IGameStateProvider) {
  class CocosStateAdapter extends Component {
    protected onLoad() {
      this.state = stateProvider.getState()
      this.unsubscribe = stateProvider.subscribe((newState) => {
        this.state = newState
        this.onStateChange(newState)
      })
    }

    protected onDestroy() {
      this.unsubscribe()
    }

    protected onStateChange(newState: GameState) {
      // 子类实现
    }
  }

  return CocosStateAdapter
}
```

---

## 进入下一阶段条件

✅ 所有任务清单完成
✅ 所有功能实现完整
✅ 所有单元测试通过
✅ 测试覆盖率 > 80%
✅ TypeScript类型检查通过
✅ ESLint代码检查通过

---

## 下一步

完成阶段3.6后，阶段3的所有基础系统已完成，可以继续执行阶段4-高级系统实现

**重要提醒：** 确保所有测试通过且覆盖率达标后再进入下一阶段！
